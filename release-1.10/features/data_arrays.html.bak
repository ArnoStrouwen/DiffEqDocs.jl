<!DOCTYPE html>

<html lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Data Arrays · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../../versions.js"></script><meta content="noindex" name="robots"/></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><form action="../search.html" class="search"><select id="version-selector" onchange="window.location.href=this.value"><option disabled="disabled" selected="selected" value="#">Version</option></select><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Types</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Types</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Types</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Types</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li><li><a class="toctext" href="../types/stokes_types.html">Stokes Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li><li><a class="toctext" href="../solvers/fdmstokes_solve.html">Stokes Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li class="current"><a class="toctext" href="data_arrays.html">Data Arrays</a><ul class="internal"><li><a class="toctext" href="#The-Data-Array-Interface-1">The Data Array Interface</a></li><li><a class="toctext" href="#Example:-A-Control-Problem-1">Example: A Control Problem</a></li><li><a class="toctext" href="#Data-Arrays-vs-ParameterizedFunctions-1">Data Arrays vs ParameterizedFunctions</a></li></ul></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="output_specification.html">Output Specification</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="data_arrays.html">Data Arrays</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/92510cd03ca166025e13e00073be6f5f6cbdc71d/docs/src/features/data_arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" href="#Data-Arrays-1" id="Data-Arrays-1">Data Arrays</a></h1><p>In many cases, a standard array may not be enough to fully hold the data for a model. Many of the solvers in DifferentialEquations.jl allow you to solve problems on <code>AbstractArray</code> types which allow you to extend the meaning of an array. The <code>DEDataArray{T}</code> type allows one to add other "non-continuous" variables to an array, which can be useful in many modeling situations involving lots of events.</p><h2><a class="nav-anchor" href="#The-Data-Array-Interface-1" id="The-Data-Array-Interface-1">The Data Array Interface</a></h2><p>To define an <code>DEDataArray</code>, make a type which subtypes <code>DEDataArray{T}</code> with a field <code>x</code> for the "array of continuous variables" for which you would like the differential equation to treat directly. For example:</p><pre><code class="language-julia">type MyDataArray{T} &lt;: DEDataArray{T}
    x::Array{T,1}
    a::T
    b::Symbol
end</code></pre><p>In this example, our resultant array is a <code>SimType</code>, and its data which is presented to the differential equation solver will be the array <code>x</code>. Any array which the differential equation solver can use is allowed to be made as the field <code>x</code>, including other <code>DEDataArray</code>s. Other than that, you can add whatever fields you please, and let them be whatever type you please. These extra fields are carried along in the differential equation solver that the user can use in their <code>f</code> equation and modify via callbacks.</p><h2><a class="nav-anchor" href="#Example:-A-Control-Problem-1" id="Example:-A-Control-Problem-1">Example: A Control Problem</a></h2><p>In this example we will use a <code>DEDataArray</code> to solve a problem where control parameters change at various timepoints. First we will build</p><pre><code class="language-julia">type SimType{T} &lt;: DEDataArray{T}
    x::Array{T,1}
    f1::T
end</code></pre><p>as our <code>DEDataArray</code>. It has an extra field <code>f1</code> which we will use as our control variable. Our ODE function will use this field as follows:</p><pre><code class="language-julia">function f(t,u,du)
    du[1] = -0.5*u[1] + u.f1
    du[2] = -0.5*u[2]
end</code></pre><p>Now we will setup our control mechanism. It will be a simple setup which uses set timepoints at which we will change <code>f1</code>. At <code>t=5.0</code> we will want to increase the value of <code>f1</code>, and at <code>t=8.0</code> we will want to decrease the value of <code>f1</code>. Using the <a href="callback_functions.html"><code>DiscreteCallback</code> interface</a>, we code these conditions as follows:</p><pre><code class="language-julia">const tstop1 = [5.]
const tstop2 = [8.]


function condition(t,u,integrator)
  t in tstop1
end

function condition2(t,u,integrator)
  t in tstop2
end</code></pre><p>Now we have to apply an affect when these conditions are reached. When <code>condition</code> is hit (at <code>t=5.0</code>), we will increase <code>f1</code> to 1.5. When <code>condition2</code> is reached, we will decrease <code>f1</code> to <code>-1.5</code>. This is done via the affects:</p><pre><code class="language-julia">function affect!(integrator)
  for c in user_cache(integrator)
    c.f1 = 1.5
  end
end

function affect2!(integrator)
  for c in user_cache(integrator)
    c.f1 = -1.5
  end
end</code></pre><p>Notice that we have to loop through the <code>user_cache</code> array (provided by the integrator interface) to ensure that all internal caches are also updated. With these functions we can build our callbacks:</p><pre><code class="language-julia">save_positions = (true,true)

cb = DiscreteCallback(condition, affect!, save_positions=save_positions)

save_positions = (false,true)

cb2 = DiscreteCallback(condition2, affect2!, save_positions=save_positions)

cbs = CallbackSet(cb,cb2)</code></pre><p>Now we define our initial condition. We will start at <code>[10.0;10.0]</code> with <code>f1=0.0</code>.</p><pre><code class="language-julia">u0 = SimType([10.0;10.0], 0.0)
prob = ODEProblem(f,u0,(0.0,10.0))</code></pre><p>Lastly we solve the problem. Note that we must pass <code>tstop</code> values of <code>5.0</code> and <code>8.0</code> to ensure the solver hits those timepoints exactly:</p><pre><code class="language-julia">const tstop = [5.;8.]
sol = solve(prob,Tsit5(),callback = cbs, tstops=tstop)</code></pre><p><img alt="data_array_plot" src="../assets/data_array.png"/></p><p>It's clear from the plot how the controls affected the outcome.</p><h2><a class="nav-anchor" href="#Data-Arrays-vs-ParameterizedFunctions-1" id="Data-Arrays-vs-ParameterizedFunctions-1">Data Arrays vs ParameterizedFunctions</a></h2><p>The reason for using a <code>DEDataArray</code> is because the solution will then save the control parameters. For example, we can see what the control parameter was at every timepoint by checking:</p><pre><code class="language-julia">[sol[i].f1 for i in 1:length(sol)]</code></pre><p>A similar solution can be achieved using a <code>ParameterizedFunction</code>. We could have instead created our function as:</p><pre><code class="language-julia">function f(t,u,param,du)
    du[1] = -0.5*u[1] + param
    du[2] = -0.5*u[2]
end
pf = ParameterizedFunction(f,0.0)
u0 = SimType([10.0;10.0], 0.0)
prob = ODEProblem(f,u0,(0.0,10.0))
const tstop = [5.;8.]
sol = solve(prob,Tsit5(),callback = cbs, tstops=tstop)</code></pre><p>where we now change the callbacks to changing the parameter in the function:</p><pre><code class="language-julia">function affect!(integrator)
  integrator.f.params = 1.5
end

function affect2!(integrator)
  integrator.f.params = -1.5
end</code></pre><p>This will also solve the equation and get a similar result. It will also be slightly faster in some cases. However, if the equation is solved in this manner, there will be no record of what the parameter was at each timepoint. That is the tradeoff between <code>DEDataArray</code>s and <code>ParameterizedFunction</code>s.</p><footer><hr/><a class="previous" href="performance_overloads.html"><span class="direction">Previous</span><span class="title">Performance Overloads</span></a><a class="next" href="noise_process.html"><span class="direction">Next</span><span class="title">Noise Processes</span></a></footer></article></body></html>
