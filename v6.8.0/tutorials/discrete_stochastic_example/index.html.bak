<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discrete Stochastic (Gillespie) Equations Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.juliadiffeq.org/stable/tutorials/discrete_stochastic_example/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../ode_example/">Ordinary Differential Equations</a></li><li><a class="toctext" href="../advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="toctext" href="../sde_example/">Stochastic Differential Equations</a></li><li><a class="toctext" href="../rode_example/">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../dde_example/">Delay Differential Equations</a></li><li><a class="toctext" href="../dae_example/">Differential Algebraic Equations</a></li><li class="current"><a class="toctext" href>Discrete Stochastic (Gillespie) Equations</a><ul class="internal"><li><a class="toctext" href="#Defining-a-Model-using-Reactions-1">Defining a Model using Reactions</a></li><li><a class="toctext" href="#Building-and-Solving-the-Problem-1">Building and Solving the Problem</a></li><li><a class="toctext" href="#SSAStepper-1">SSAStepper</a></li><li><a class="toctext" href="#Controlling-Saving-Behavior-1">Controlling Saving Behavior</a></li><li><a class="toctext" href="#Defining-the-Jumps-Directly:-ConstantRateJump-1">Defining the Jumps Directly: <code>ConstantRateJump</code></a></li><li><a class="toctext" href="#Defining-the-Jumps-Directly:-MassActionJump-1">Defining the Jumps Directly: <code>MassActionJump</code></a></li><li><a class="toctext" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump-1">Defining the Jumps Directly: Mixing <code>ConstantRateJump</code> and <code>MassActionJump</code></a></li><li><a class="toctext" href="#Adding-Jumps-to-a-Differential-Equation-1">Adding Jumps to a Differential Equation</a></li><li><a class="toctext" href="#Adding-a-VariableRateJump-1">Adding a VariableRateJump</a></li><li><a class="toctext" href="#RegularJumps-and-Tau-Leaping-1">RegularJumps and Tau-Leaping</a></li></ul></li><li><a class="toctext" href="../jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="toctext" href="../bvp_example/">Boundary Value Problems</a></li><li><a class="toctext" href="../additional/">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="toctext" href="../../basics/solution/">Solution Handling</a></li><li><a class="toctext" href="../../basics/plot/">Plot Functions</a></li><li><a class="toctext" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="toctext" href="../../basics/problem/">Problem Interface</a></li><li><a class="toctext" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="toctext" href="../../types/ode_types/">ODE Problems</a></li><li><a class="toctext" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="toctext" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="toctext" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="toctext" href="../../types/sde_types/">SDE Problems</a></li><li><a class="toctext" href="../../types/rode_types/">RODE Problems</a></li><li><a class="toctext" href="../../types/dde_types/">DDE Problems</a></li><li><a class="toctext" href="../../types/dae_types/">DAE Problems</a></li><li><a class="toctext" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="toctext" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="toctext" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="toctext" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="toctext" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="toctext" href="../../solvers/jump_solve/">Jump Problem Solvers</a></li><li><a class="toctext" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="toctext" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="toctext" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="toctext" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="toctext" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="toctext" href="../../features/noise_process/">Noise Processes</a></li><li><a class="toctext" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../../features/callback_library/">Callback Library</a></li><li><a class="toctext" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="toctext" href="../../features/progress_bar/">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="toctext" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="toctext" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="toctext" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="toctext" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="toctext" href="../../models/physical/">Physical Models</a></li><li><a class="toctext" href="../../models/financial/">Financial Models</a></li><li><a class="toctext" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="toctext" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><span class="toctext">DiffEqBase API</span><ul><li><a class="toctext" href="../../apis/diffeqbase/overview/">Overview</a></li><li><a class="toctext" href="../../apis/diffeqbase/functions/">DE functions</a></li><li><a class="toctext" href="../../apis/diffeqbase/problems/">Problems</a></li><li><a class="toctext" href="../../apis/diffeqbase/solutions/">Solutions</a></li><li><a class="toctext" href="../../apis/diffeqbase/solvers/">Solvers</a></li><li><a class="toctext" href="../../apis/diffeqbase/de_types/">DE types</a></li><li><a class="toctext" href="../../apis/diffeqbase/operators/">Operators</a></li><li><a class="toctext" href="../../apis/diffeqbase/callbacks/">Callbacks</a></li><li><a class="toctext" href="../../apis/diffeqbase/interpolation/">Interpolation</a></li><li><a class="toctext" href="../../apis/diffeqbase/ensembles/">Ensembles</a></li><li><a class="toctext" href="../../apis/diffeqbase/data_arrays/">Data arrays</a></li><li><a class="toctext" href="../../apis/diffeqbase/noise/">Noise processes</a></li><li><a class="toctext" href="../../apis/diffeqbase/utility/">Utility</a></li></ul></li><li><a class="toctext" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Discrete Stochastic (Gillespie) Equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/tutorials/discrete_stochastic_example.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Discrete Stochastic (Gillespie) Equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Discrete-Stochastic-(Gillespie)-Equations-1" href="#Discrete-Stochastic-(Gillespie)-Equations-1">Discrete Stochastic (Gillespie) Equations</a></h1><p>In this tutorial we will describe how to define and simulate continuous-time jump processes, also known in biological fields as Gillespie-type models. This tutorial assumes you have read the <a href="../ode_example">Ordinary Differential Equations tutorial</a>. The discrete stochastic simulations we consider are a form of jump equation with a &quot;trivial&quot; (non-existent) differential equation. We will first demonstrate how to build these types of models using the biological modeling functionality, then describe how to build them directly and more generally using jumps, and finally show how to add discrete stochastic simulations to differential equation models.</p><h2><a class="nav-anchor" id="Defining-a-Model-using-Reactions-1" href="#Defining-a-Model-using-Reactions-1">Defining a Model using Reactions</a></h2><p>For our example, we will build an SIR model which matches the tutorial from <a href="https://github.com/sdwfrost/Gillespie.jl">Gillespie.jl</a>. SIR stands for susceptible, infected, and recovered, and is a model of disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This &quot;chance&quot; is determined by the number of susceptible persons and the number of infected persons, since in larger populations there is a greater chance that two people come into contact. Normally, the rate is modeled as the amount</p><pre><code class="language-julia">rate_constant*num_of_susceptible_people*num_of_infected_people</code></pre><p>The <code>rate_constant</code> is determined by factors like the type of the disease. It can be interpreted as the probability per time one pair of susceptible and infected people encounter each other, with the susceptible person becoming sick. The overall rate (i.e. probability per time) that some susceptible person gets sick is then given by the rate constant multiplied by the number of possible pairs of susceptible and infected people. This formulation is known as the <a href="https://en.wikipedia.org/wiki/Law_of_mass_action">law of mass action</a>.</p><p>Let <code>s</code> be the number of susceptible persons, <code>i</code> be the number of infected persons, and <code>r</code> be the number of recovered persons. In this case, we can re-write our overall rate as:</p><pre><code class="language-julia">rate_constant*s*i</code></pre><p>Thus we have that our &quot;reactants&quot; are components 1 and 2. When this &quot;reaction&quot; occurs, the result is that one susceptible person turns into an infected person. We can think of this as doing:</p><pre><code class="language-julia">s -= 1
i += 1</code></pre><p>that is, we decrease the number of susceptible persons by 1 and increase the number of infected persons by 1.</p><p>These are the facts the are encoded in the reaction:</p><pre><code class="language-none">c1, s + i --&gt; 2i</code></pre><p>This &quot;reaction&quot; encodes that a susceptible person and an infected person can interact, resulting in two infected persons (i.e. the susceptible person was infected). Here, <code>c1</code> is the reaction constant.</p><p>To finish the model, we define one more reaction. Over time, infected people become less infected. The chance that any one person heals during some time unit depends on the number of people who are infected. Thus the rate at which infected people turn into recovered people is</p><pre><code class="language-julia">rate_constant*i</code></pre><p>When this happens, we lose one infected person and gain a recovered person. This reaction is thus modeled as:</p><pre><code class="language-julia">c2, i --&gt; r</code></pre><p>Thus our full reaction network is:</p><pre><code class="language-julia"># ]add DiffEqBiological
using DiffEqBiological
sir_model = @reaction_network SIR begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end c1 c2</code></pre><p>Notice that the order the variables are introduced in the model is <code>s</code>, then <code>i</code>, then <code>r</code>, and thus this is the canonical ordering of the variables.</p><h2><a class="nav-anchor" id="Building-and-Solving-the-Problem-1" href="#Building-and-Solving-the-Problem-1">Building and Solving the Problem</a></h2><p>First, we have to define some kind of differential equation that we can &quot;solve&quot; to simulate the jump process. Since we do not want any continuous changes in the numbers of the different types of people, we will build a <code>DiscreteProblem</code>. We do this by giving the constructor <code>u0</code>, the initial condition, and <code>tspan</code>, the timespan. Here, we will start with <code>999</code> susceptible people, <code>1</code> infected person, and <code>0</code> recovered people, and solve the problem from <code>t=0.0</code> to <code>t=250.0</code>. We use the parameters <code>c1 = 0.1/1000</code> and <code>c2 = 0.01</code>. Thus we build the problem via:</p><pre><code class="language-julia">p = (0.1/1000,0.01)
prob = DiscreteProblem([999,1,0],(0.0,250.0),p)</code></pre><p>The reaction network can be converted into various differential equations like <code>JumpProblem</code>, <code>ODEProblem</code>, or an <code>SDEProblem</code>. To turn it into a jump problem, we simply do:</p><pre><code class="language-julia">jump_prob = JumpProblem(prob,Direct(),sir_model)</code></pre><p>This is now a problem that can be solved using the differential equations solvers. Since our problem is discrete, we will use the <code>FunctionMap()</code> method.</p><pre><code class="language-julia">sol = solve(jump_prob,FunctionMap())</code></pre><p>This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:</p><pre><code class="language-julia">using Plots; plot(sol)</code></pre><p><img src="../../assets/gillespie_solution.png" alt="gillespie_solution"/></p><h2><a class="nav-anchor" id="SSAStepper-1" href="#SSAStepper-1">SSAStepper</a></h2><p>The previous example used <code>FunctionMap()</code> to perform the jump process simulation. <code>FunctionMap</code> is a <code>DiscreteProblem</code> algorithm in OrdinaryDiffEq.jl. This shows that any common interface algorithm can be used to perform the timestepping since this is implemented over the callback interface. In many cases we may have a pure jump system that only involves <code>ConstantRateJump</code>s and/or <code>MassActionJump</code>s. When that&#39;s the case, a substantial performance benefit may be gained by using <code>SSAStepper()</code></p><pre><code class="language-julia">sol = solve(jump_prob,SSAStepper())</code></pre><p><code>SSAStepper</code> is a barebones SSA method which doesn&#39;t allow defining events or integrating simultaneous ODEs, but is very efficient for pure jump/SSA problems.</p><h2><a class="nav-anchor" id="Controlling-Saving-Behavior-1" href="#Controlling-Saving-Behavior-1">Controlling Saving Behavior</a></h2><p>Note that jumps act via the callback interface which defaults to saving at each event. The reason is because this is required in order to accurately resolve every discontinuity exactly (and this is what allows for perfectly vertical lines!). However, in many cases when using jump problems you may wish to decrease the saving pressure given by large numbers of jumps. To do this, you set <code>save_positions</code> in the <code>JumpProblem</code>. Just like for other callbacks, this is a tuple <code>(bool1,bool2)</code> which saves whether to save before or after a jump. If we do not want to save at every jump, we would thus pass:</p><pre><code class="language-julia">jump_prob = JumpProblem(prob,Direct(),sir_model,save_positions=(false,false))</code></pre><p>Now the saving controls associated with the integrator are the only ones to note. For example, we can use <code>saveat=0.5</code> to save at an evenly spaced grid:</p><pre><code class="language-julia">sol = solve(jump_prob,FunctionMap(),saveat=0.5)</code></pre><h2><a class="nav-anchor" id="Defining-the-Jumps-Directly:-ConstantRateJump-1" href="#Defining-the-Jumps-Directly:-ConstantRateJump-1">Defining the Jumps Directly: <code>ConstantRateJump</code></a></h2><p>Instead of using the biological modeling functionality of <code>@reaction_network</code>, we can directly define jumps. This allows for more general types of rates, at the cost of some modeling friendliness. The constructor for a <code>ConstantRateJump</code> is:</p><pre><code class="language-julia">jump = ConstantRateJump(rate,affect!)</code></pre><p>where <code>rate</code> is a function <code>rate(u,p,t)</code> and <code>affect!</code> is a function of the integrator <code>affect!(integrator)</code> (for details on the integrator, see the <a href="http://docs.juliadiffeq.org/dev/basics/integrator">integrator interface docs</a>). Thus, to define the jump equivalents to the above reactions, we can use:</p><pre><code class="language-julia">rate1(u,p,t) = (0.1/1000.0)*u[1]*u[2]
function affect1!(integrator)
  integrator.u[1] -= 1
  integrator.u[2] += 1
end
jump = ConstantRateJump(rate1,affect1!)

rate2(u,p,t) = 0.01u[2]
function affect2!(integrator)
  integrator.u[2] -= 1
  integrator.u[3] += 1
end
jump2 = ConstantRateJump(rate2,affect2!)</code></pre><p>We can then use <code>JumpProblem</code> to augment a problem with jumps. To add the jumps to the <code>DiscreteProblem</code> and solve it, we would simply do:</p><pre><code class="language-julia">jump_prob = JumpProblem(prob,Direct(),jump,jump2)
sol = solve(jump_prob,FunctionMap())</code></pre><p>Note, in systems with more than a few jumps (more than ~10), it can be advantageous to use a different internal representation for the jump collection. For such systems it is recommended to use <code>DirectFW()</code>, which should offer better performance than <code>Direct()</code>.</p><h2><a class="nav-anchor" id="Defining-the-Jumps-Directly:-MassActionJump-1" href="#Defining-the-Jumps-Directly:-MassActionJump-1">Defining the Jumps Directly: <code>MassActionJump</code></a></h2><p>For systems that can be represented as mass action reactions, a further specialization of the jump type is possible that offers improved computational performance; <code>MasssActionJump</code>. Suppose the system has <span>$N$</span> chemical species <span>$\{S_1,\dots,S_N\}$</span>. A general mass action reaction has the form</p><div>\[R_1 S_1 + R_2 S_2 + \dots + R_N S_N \overset{k}{\rightarrow} P_1 S_1 + P_2 S_2 + \dots + P_N S_N\]</div><p>where the non-negative integers <span>$(R_1,\dots,R_N)$</span> denote the <em>reactant stoichiometry</em> of the reaction, and the non-negative integers <span>$(P_1,\dots,P_N)$</span> the <em>product stoichiometry</em>. The <em>net stoichiometry</em> is the net change in each chemical species from the reaction occurring one time, given by <span>$(P_1-R_1,\dots,P_N-R_N)$</span>.</p><p>As an example, consider again the SIR model defined in the <code>@reaction_network</code> above. The species are then <code>(s,i,r)</code>. The first reaction has rate <code>c1</code>, reactant stoichiometry <code>(1,1,0)</code>, product stoichiometry <code>(0,2,0)</code>, and net stoichiometry <code>(-1,1,0)</code>. The second reaction has rate <code>c2</code>, reactant stoichiometry <code>(0,1,0)</code>, product stoichiometry <code>(0,0,1)</code>, and net stoichiometry <code>(0,-1,1)</code>.</p><p>We can encode this system as a mass action jump by specifying the rates, reactant stoichiometry, and the net stoichiometry as follows:</p><pre><code class="language-julia">rates = [0.1/1000, 0.01]    # i.e. [c1,c2]
reactant_stoich =
[
  [1 =&gt; 1, 2 =&gt; 1],         # 1*s and 1*i
  [2 =&gt; 1]                  # 1*i
]
net_stoich =
[
  [1 =&gt; -1, 2 =&gt; 1],        # -1*s and 1*i
  [2 =&gt; -1, 3 =&gt; 1]         # -1*i and 1*r
]
mass_act_jump = MassActionJump(rates, reactant_stoich, net_stoich)</code></pre><p>Just like for <code>ConstantRateJumps</code>, to then simulate the system we create a <code>JumpProblem</code> and call <code>solve</code>:</p><pre><code class="language-julia">jump_prob = JumpProblem(prob, Direct(), mass_act_jump)
sol = solve(jump_prob, SSAStepper())</code></pre><h2><a class="nav-anchor" id="Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump-1" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump-1">Defining the Jumps Directly: Mixing <code>ConstantRateJump</code> and <code>MassActionJump</code></a></h2><p>Suppose we now want to add in to the SIR model another jump that can not be represented as a mass action reaction. We can create a new <code>ConstantRateJump</code> and simulate a hybrid system using both the <code>MassActionJump</code> for the two previous reactions, and the new <code>ConstantRateJump</code>. Let&#39;s suppose we want to let susceptible people be born with the following jump rate:</p><pre><code class="language-julia">birth_rate(u,p,t) = 10.*u[1]/(200. + u[1]) + 10.
function birth_affect!(integrator)
  integrator.u[1] += 1
end
birth_jump = ConstantRateJump(birth_rate, birth_affect!)</code></pre><p>We can then simulate the hybrid system as</p><pre><code class="language-julia">jump_prob = JumpProblem(prob, Direct(), mass_act_jump, birth_jump)
sol = solve(jump_prob, SSAStepper())</code></pre><p><img src="../../assets/gillespie_hybrid_jumps.png" alt="gillespie_hybrid_jumps"/></p><h2><a class="nav-anchor" id="Adding-Jumps-to-a-Differential-Equation-1" href="#Adding-Jumps-to-a-Differential-Equation-1">Adding Jumps to a Differential Equation</a></h2><p>Notice that if we instead used some form of differential equation instead of a <code>DiscreteProblem</code>, we would add the jumps/reactions to the differential equation. Let&#39;s define an ODE problem, where the continuous part only acts on some new 4th component:</p><pre><code class="language-julia">function f(du,u,p,t)
  du[4] = u[2]*u[3]/100000 - u[1]*u[2]/100000
end

prob = ODEProblem(f,[999.0,1.0,0.0,100.0],(0.0,250.0))</code></pre><p>Notice we gave the 4th component a starting value of 100. The same steps as above will allow us to solve this hybrid equation when using <code>ConstantRateJumps</code>. For example, we can solve it using the <code>Tsit5()</code> method via:</p><pre><code class="language-julia">jump_prob = JumpProblem(prob,Direct(),jump,jump2)
sol = solve(jump_prob,Tsit5())</code></pre><p><img src="../../assets/gillespie_ode.png" alt="gillespie_ode"/></p><h3><a class="nav-anchor" id="Caution-about-Constant-Rate-Jumps-1" href="#Caution-about-Constant-Rate-Jumps-1">Caution about Constant Rate Jumps</a></h3><p>Note that the assumption which is required for constant rate jumps is that their reaction rates must be constant on the interval between any constant rate jumps. Thus in the examples above,</p><pre><code class="language-julia">rate(u,p,t) = (0.1/1000.0)*u[1]*u[2]
rate(u,p,t) = 0.01u[2]</code></pre><p>both must be constant other than changes due to some constant rate jump (the same applies to reactions). Since these rates only change when <code>u[1]</code> or <code>u[2]</code> is changed, and <code>u[1]</code> and <code>u[2]</code> only change when one of the jumps occur, this setup is valid. However, <code>t*(0.1/1000.0)*u[1]*u[2]</code> would not be valid because the rate would change during the interval, as would <code>(0.1/1000.0)*u[1]*u[4]</code>. Thus one must be careful about to follow this rule when choosing rates.</p><p>(but note that it&#39;s okay for <code>u[4]</code> to depend on the other variables because its updated in a continuous manner!)</p><p>If your problem must have the rates depend on a continuously changing quantity, you need to use the <code>VariableRateJump</code> or <code>VariableRateReaction</code> instead.</p><h2><a class="nav-anchor" id="Adding-a-VariableRateJump-1" href="#Adding-a-VariableRateJump-1">Adding a VariableRateJump</a></h2><p>Now let&#39;s consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let&#39;s let there be a new reaction which has the same effect as <code>r2</code>, but now is dependent on the amount of <code>u[4]</code>.</p><pre><code class="language-julia">rate3(u,p,t) = 1e-2u[4]
function affect3!(integrator)
  integrator.u[2] -= 1
  integrator.u[3] += 1
end
jump3 = VariableRateJump(rate3,affect3!)</code></pre><p>We would expect this reaction to increase the amount of transitions from state 2 to 3. Solving the equation is exactly the same:</p><pre><code class="language-julia">prob = ODEProblem(f,[999.0,1.0,0.0,1.0],(0.0,250.0))
jump_prob = JumpProblem(prob,Direct(),jump,jump2,jump3)
sol = solve(jump_prob,Tsit5())</code></pre><p><img src="../../assets/variable_rate_gillespie.png" alt="variable_rate_gillespie"/></p><p>Notice that this increases the amount of 3 at the end, reducing the falloff in the rate (though this model is kind of nonsensical).</p><p>Note that even if the problem is a <code>DiscreteProblem</code>, <code>VariableRateJump</code>s and <code>VariableRateReaction</code>s require a continuous solver, like an ODE/SDE/DDE/DAE solver.</p><p>Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on <code>u[4]</code> by using an <code>SDEProblem</code> instead:</p><pre><code class="language-julia">function g(du,u,p,t)
  du[4] = 0.1u[4]
end

prob = SDEProblem(f,g,[999.0,1.0,0.0,1.0],(0.0,250.0))
jump_prob = JumpProblem(prob,Direct(),jump,jump2,jump3)
sol = solve(jump_prob,SRIW1())</code></pre><p><img src="../../assets/sde_gillespie.png" alt="sde_gillespie"/></p><h2><a class="nav-anchor" id="RegularJumps-and-Tau-Leaping-1" href="#RegularJumps-and-Tau-Leaping-1">RegularJumps and Tau-Leaping</a></h2><p>The previous parts described how to use <code>ConstantRateJump</code> and <code>VariableRateJump</code> to add jumps to differential equation algorithms over the callback interface. However, in many cases you do not need to step to every jump time. Instead, regular jumping allows you to pool together jumps and perform larger updates in a statistically-correct but more efficient manner.</p><p>For <code>RegularJump</code>s, we pool together the jumps we wish to perform. Here our <code>rate</code> is a vector equation which computes the rates of each jump process together:</p><pre><code class="language-julia">function rate(out,u,p,t)
    out[1] = (0.1/1000.0)*u[1]*u[2]
    out[2] = 0.01u[2]
end</code></pre><p>and then we compute the total change matrix <code>c</code></p><pre><code class="language-julia">function c(dc,u,p,t,mark)
    dc[1,1] = -1
    dc[2,1] = 1
    dc[2,2] = -1
    dc[3,2] = 1
end</code></pre><p>where each column is a different jump process. We then declare the form of <code>dc</code> and build a <code>RegularJump</code>:</p><pre><code class="language-julia">dc = zeros(3,2)
rj = RegularJump(rate,c,dc;constant_c=true)</code></pre><p>From there we build a <code>JumpProblem</code>:</p><pre><code class="language-julia">prob = DiscreteProblem([999.0,1.0,0.0],(0.0,250.0))
jump_prob = JumpProblem(prob,Direct(),rj)</code></pre><p>Note that when a <code>JumpProblem</code> has a <code>RegularJump</code>, special algorithms are required. This is detailed on <a href="http://docs.juliadiffeq.org/dev/solvers/jump_solve">the jump solvers page</a>. One such algorithm is <code>SimpleTauLeaping</code>, which we use as follows:</p><pre><code class="language-julia">sol = solve(jump_prob,SimpleTauLeaping();dt=1.0)</code></pre><footer><hr/><a class="previous" href="../dae_example/"><span class="direction">Previous</span><span class="title">Differential Algebraic Equations</span></a><a class="next" href="../jump_diffusion/"><span class="direction">Next</span><span class="title">Jump Diffusion Equations</span></a></footer></article></body></html>
