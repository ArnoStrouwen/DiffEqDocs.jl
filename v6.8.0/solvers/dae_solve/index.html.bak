<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DAE Solvers Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.juliadiffeq.org/stable/solvers/dae_solve/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="toctext" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="toctext" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="toctext" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="toctext" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="toctext" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="toctext" href="../../basics/solution/">Solution Handling</a></li><li><a class="toctext" href="../../basics/plot/">Plot Functions</a></li><li><a class="toctext" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="toctext" href="../../basics/problem/">Problem Interface</a></li><li><a class="toctext" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="toctext" href="../../types/ode_types/">ODE Problems</a></li><li><a class="toctext" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="toctext" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="toctext" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="toctext" href="../../types/sde_types/">SDE Problems</a></li><li><a class="toctext" href="../../types/rode_types/">RODE Problems</a></li><li><a class="toctext" href="../../types/dde_types/">DDE Problems</a></li><li><a class="toctext" href="../../types/dae_types/">DAE Problems</a></li><li><a class="toctext" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../discrete_solve/">Discrete Solvers</a></li><li><a class="toctext" href="../ode_solve/">ODE Solvers</a></li><li><a class="toctext" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="toctext" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="toctext" href="../bvp_solve/">BVP Solvers</a></li><li><a class="toctext" href="../jump_solve/">Jump Problem Solvers</a></li><li><a class="toctext" href="../sde_solve/">SDE Solvers</a></li><li><a class="toctext" href="../rode_solve/">RODE Solvers</a></li><li><a class="toctext" href="../dde_solve/">DDE Solvers</a></li><li class="current"><a class="toctext" href>DAE Solvers</a><ul class="internal"><li><a class="toctext" href="#Recomended-Methods-1">Recomended Methods</a></li><li><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li></ul></li><li><a class="toctext" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="toctext" href="../../features/noise_process/">Noise Processes</a></li><li><a class="toctext" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../../features/callback_library/">Callback Library</a></li><li><a class="toctext" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="toctext" href="../../features/progress_bar/">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="toctext" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="toctext" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="toctext" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="toctext" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="toctext" href="../../models/physical/">Physical Models</a></li><li><a class="toctext" href="../../models/financial/">Financial Models</a></li><li><a class="toctext" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="toctext" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><span class="toctext">DiffEqBase API</span><ul><li><a class="toctext" href="../../apis/diffeqbase/overview/">Overview</a></li><li><a class="toctext" href="../../apis/diffeqbase/functions/">DE functions</a></li><li><a class="toctext" href="../../apis/diffeqbase/problems/">Problems</a></li><li><a class="toctext" href="../../apis/diffeqbase/solutions/">Solutions</a></li><li><a class="toctext" href="../../apis/diffeqbase/solvers/">Solvers</a></li><li><a class="toctext" href="../../apis/diffeqbase/de_types/">DE types</a></li><li><a class="toctext" href="../../apis/diffeqbase/operators/">Operators</a></li><li><a class="toctext" href="../../apis/diffeqbase/callbacks/">Callbacks</a></li><li><a class="toctext" href="../../apis/diffeqbase/interpolation/">Interpolation</a></li><li><a class="toctext" href="../../apis/diffeqbase/ensembles/">Ensembles</a></li><li><a class="toctext" href="../../apis/diffeqbase/data_arrays/">Data arrays</a></li><li><a class="toctext" href="../../apis/diffeqbase/noise/">Noise processes</a></li><li><a class="toctext" href="../../apis/diffeqbase/utility/">Utility</a></li></ul></li><li><a class="toctext" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Algorithms</li><li><a href>DAE Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/solvers/dae_solve.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DAE Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DAE-Solvers-1" href="#DAE-Solvers-1">DAE Solvers</a></h1><h2><a class="nav-anchor" id="Recomended-Methods-1" href="#Recomended-Methods-1">Recomended Methods</a></h2><p>For medium to low accuracy DAEs in mass matrix form, the <code>Rodas4</code> and <code>Rodas42</code> methods are good choices which will get good efficiency. The OrdinaryDiffEq.jl methods are also the only methods which allow for Julia-defined number types. For high accuracy (error <code>&lt;1e-7</code>) on problems of <code>Vector{Float64}</code> defined in mass matrix form, <code>radau</code> is an efficient method.</p><p>If the problem cannot be defined in mass matrix form, the recommended method for performance is <code>IDA</code> from the Sundials.jl package if you are solving problems with <code>Float64</code>. It&#39;s a very well-optimized method, and allows you to have a little bit of control over the linear solver to better tailor it to your problem. A similar algorithm is <code>daskr</code>. Which one is more efficient is problem-dependent.</p><h2><a class="nav-anchor" id="Full-List-of-Methods-1" href="#Full-List-of-Methods-1">Full List of Methods</a></h2><h3><a class="nav-anchor" id="OrdinaryDiffEq.jl-1" href="#OrdinaryDiffEq.jl-1">OrdinaryDiffEq.jl</a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><h4><a class="nav-anchor" id="Rosenbrock-Methods-1" href="#Rosenbrock-Methods-1">Rosenbrock Methods</a></h4><ul><li><code>ROS3P</code> - 3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</li><li><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</li><li><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</li><li><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</li><li><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</li><li><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</li><li><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially &quot;anti-L-stable&quot; but efficient.</li><li><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</li><li><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</li><li><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method. Currently has a Hermite interpolant because its stiff-aware 3rd order interpolant is not yet implemented.</li></ul><h4><a class="nav-anchor" id="Rosenbrock-W-Methods-1" href="#Rosenbrock-W-Methods-1">Rosenbrock-W Methods</a></h4><ul><li><code>Rosenbrock23</code> - An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</li><li><code>Rosenbrock32</code> - An Order 3/2 A-Stable Rosenbrock-W method which is good for mildy stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</li><li><code>RosenbrockW6S4OS</code> - A 4th order L-stable Rosenbrock-W method (fixed step only).</li><li><code>ROS34PW1a</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW1b</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW2</code> - A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</li><li><code>ROS34PW3</code> - A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</li></ul><h4><a class="nav-anchor" id="SDIRK-Methods-1" href="#SDIRK-Methods-1">SDIRK Methods</a></h4><p>SDIRK Methods</p><ul><li><code>ImplicitEuler</code> - Stage order 1. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory. Strong-stability presurving (SSP).</li><li><code>ImplicitMidpoint</code> - Stage order 1. Symplectic. Good for when symplectic integration is required.</li></ul><h3><a class="nav-anchor" id="Sundials.jl-1" href="#Sundials.jl-1">Sundials.jl</a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use Sundials.jl:</p><pre><code class="language-julia">]add Sundials
using Sundials</code></pre><ul><li><code>IDA</code> - This is the IDA method from the Sundials.jl package.</li></ul><p>Note that the constructors for the Sundials algorithms take a main argument:</p><ul><li><p><code>linearsolver</code> - This is the linear solver which is used in the Newton iterations. The choices are:</p><ul><li><code>:Dense</code> - A dense linear solver.</li><li><code>:Band</code> - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via <code>jac_upper</code> and <code>jac_lower</code>.</li><li><code>:GMRES</code> - A GMRES method. Recommended first choice Krylov method</li><li><code>:BCG</code> - A Biconjugate gradient method.</li><li><code>:PCG</code> - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li><code>:TFQMR</code> - A TFQMR method.</li><li><code>:KLU</code> - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the <code>ODEProblem</code> type.</li></ul></li></ul><p>Example:</p><pre><code class="language-julia">IDA() # Newton + Dense solver
IDA(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
IDA(linear_solver=:BCG) # Biconjugate gradient method                                   </code></pre><p>All of the additional options are available. The constructor is:</p><pre><code class="language-julia">IDA(;linear_solver=:Dense,jac_upper=0,jac_lower=0,krylov_dim=0,
    max_order = 5,
    max_error_test_failures = 7,
    max_nonlinear_iters = 3,
    nonlinear_convergence_coefficient = 0.33,
    nonlinear_convergence_coefficient_ic = 0.0033,
    max_num_steps_ic = 5,
    max_num_jacs_ic = 4,
    max_num_iters_ic = 10,
    max_num_backs_ic = 100,
    use_linesearch_ic = true,
    max_convergence_failures = 10,
    init_all = false,
    prec = nothing, psetup = nothing, prec_side = 0)</code></pre><p>See <a href="https://computation.llnl.gov/sites/default/files/public/ida_guide.pdf">the Sundials manual</a> for details on the additional options. The option <code>init_all</code> controls the initial condition consistency routine. If the initial conditions are inconsistant (i.e. they do not satisfy the implicit equation), <code>init_all=false</code> means that the algebraic variables and derivatives will be modified in order to satisfy the DAE. If <code>init_all=true</code>, all initial conditions will be modified to satify the DAE.</p><p>Note that here <code>prec</code> is a preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta,lr)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li><li><code>lr</code>: a flag for whether <code>lr=1</code> (left) or <code>lr=2</code> (right) preconditioning</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>resid</code>: the current residual</li><li><code>u</code>: the current state</li><li><code>du</code>: the current <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><h3><a class="nav-anchor" id="DASKR.jl-1" href="#DASKR.jl-1">DASKR.jl</a></h3><p>DASKR.jl is not automatically included by DifferentialEquations.jl. To use this algorithm, you will need to install and use the package:</p><pre><code class="language-julia">]add DASKR
using DASKR</code></pre><ul><li><code>daskr</code> - This is a wrapper for the well-known DASKR algorithm.</li></ul><p>All additional options are available. The constructor is:</p><pre><code class="language-julia">function daskr(;linear_solver=:Dense,
                  jac_upper=0,jac_lower=0,max_order = 5,
                  non_negativity_enforcement = 0,
                  non_negativity_enforcement_array = nothing,
                  max_krylov_iters = nothing,
                  num_krylov_vectors = nothing,
                  max_number_krylov_restarts = 5,
                  krylov_convergence_test_constant = 0.05,
                  exclude_algebraic_errors = false)</code></pre><p>Choices for the linear solver are:</p><ul><li><code>:Dense</code></li><li><code>:Banded</code></li><li><code>:SPIGMR</code>, a Krylov method</li></ul><h3><a class="nav-anchor" id="DASSL.jl-1" href="#DASSL.jl-1">DASSL.jl</a></h3><ul><li><code>dassl</code> - A native Julia implementation of the DASSL algorithm.</li></ul><h3><a class="nav-anchor" id="ODEInterfaceDiffEq.jl-1" href="#ODEInterfaceDiffEq.jl-1">ODEInterfaceDiffEq.jl</a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><ul><li><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</li><li><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</li><li><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</li><li><code>rodas</code> - Rosenbrock 4(3) method.</li></ul><footer><hr/><a class="previous" href="../dde_solve/"><span class="direction">Previous</span><span class="title">DDE Solvers</span></a><a class="next" href="../benchmarks/"><span class="direction">Next</span><span class="title">Solver Benchmarks</span></a></footer></article></body></html>
