<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Ensemble Simulations Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.juliadiffeq.org/stable/features/ensemble/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="toctext" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="toctext" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="toctext" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="toctext" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="toctext" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="toctext" href="../../basics/solution/">Solution Handling</a></li><li><a class="toctext" href="../../basics/plot/">Plot Functions</a></li><li><a class="toctext" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="toctext" href="../../basics/problem/">Problem Interface</a></li><li><a class="toctext" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="toctext" href="../../types/ode_types/">ODE Problems</a></li><li><a class="toctext" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="toctext" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="toctext" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="toctext" href="../../types/sde_types/">SDE Problems</a></li><li><a class="toctext" href="../../types/rode_types/">RODE Problems</a></li><li><a class="toctext" href="../../types/dde_types/">DDE Problems</a></li><li><a class="toctext" href="../../types/dae_types/">DAE Problems</a></li><li><a class="toctext" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="toctext" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="toctext" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="toctext" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="toctext" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="toctext" href="../../solvers/jump_solve/">Jump Problem Solvers</a></li><li><a class="toctext" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="toctext" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="toctext" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="toctext" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="toctext" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../diffeq_operator/">DiffEqOperators</a></li><li><a class="toctext" href="../noise_process/">Noise Processes</a></li><li><a class="toctext" href="../linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../callback_functions/">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../callback_library/">Callback Library</a></li><li class="current"><a class="toctext" href>Parallel Ensemble Simulations</a><ul class="internal"><li><a class="toctext" href="#Performing-an-Ensemble-Simulation-1">Performing an Ensemble Simulation</a></li><li><a class="toctext" href="#Analyzing-an-Ensemble-Experiment-1">Analyzing an Ensemble Experiment</a></li><li><a class="toctext" href="#Example-1:-Solving-an-ODE-With-Different-Initial-Conditions-1">Example 1: Solving an ODE With Different Initial Conditions</a></li><li><a class="toctext" href="#Example-2:-Solving-an-SDE-with-Different-Parameters-1">Example 2: Solving an SDE with Different Parameters</a></li><li><a class="toctext" href="#Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance-1">Example 3: Using the Reduction to Halt When Estimator is Within Tolerance</a></li><li><a class="toctext" href="#Example-4:-Using-the-Analysis-Tools-1">Example 4: Using the Analysis Tools</a></li></ul></li><li><a class="toctext" href="../io/">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../low_dep/">Low Dependency Usage</a></li><li><a class="toctext" href="../progress_bar/">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="toctext" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="toctext" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="toctext" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="toctext" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="toctext" href="../../models/physical/">Physical Models</a></li><li><a class="toctext" href="../../models/financial/">Financial Models</a></li><li><a class="toctext" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="toctext" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><span class="toctext">DiffEqBase API</span><ul><li><a class="toctext" href="../../apis/diffeqbase/overview/">Overview</a></li><li><a class="toctext" href="../../apis/diffeqbase/functions/">DE functions</a></li><li><a class="toctext" href="../../apis/diffeqbase/problems/">Problems</a></li><li><a class="toctext" href="../../apis/diffeqbase/solutions/">Solutions</a></li><li><a class="toctext" href="../../apis/diffeqbase/solvers/">Solvers</a></li><li><a class="toctext" href="../../apis/diffeqbase/de_types/">DE types</a></li><li><a class="toctext" href="../../apis/diffeqbase/operators/">Operators</a></li><li><a class="toctext" href="../../apis/diffeqbase/callbacks/">Callbacks</a></li><li><a class="toctext" href="../../apis/diffeqbase/interpolation/">Interpolation</a></li><li><a class="toctext" href="../../apis/diffeqbase/ensembles/">Ensembles</a></li><li><a class="toctext" href="../../apis/diffeqbase/data_arrays/">Data arrays</a></li><li><a class="toctext" href="../../apis/diffeqbase/noise/">Noise processes</a></li><li><a class="toctext" href="../../apis/diffeqbase/utility/">Utility</a></li></ul></li><li><a class="toctext" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href>Parallel Ensemble Simulations</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/ensemble.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Parallel Ensemble Simulations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Parallel-Ensemble-Simulations-1" href="#Parallel-Ensemble-Simulations-1">Parallel Ensemble Simulations</a></h1><p>Performing Monte Carlo simulations, solving with a predetermined set of initial conditions, and GPU-parallelizing a parameter search all fall under the ensemble simulation interface. This interface allows one to declare a template DEProblem to parallelize, how to tweak the template in <code>trajectories</code> many trajectories, solve each in parallel batches, reduce the solutions down to specific answers, and compute summary statistics on the results.</p><h2><a class="nav-anchor" id="Performing-an-Ensemble-Simulation-1" href="#Performing-an-Ensemble-Simulation-1">Performing an Ensemble Simulation</a></h2><h3><a class="nav-anchor" id="Building-a-Problem-1" href="#Building-a-Problem-1">Building a Problem</a></h3><p>To perform a simulation on an ensemble of trajectories, define a <code>EnsembleProblem</code>. The constructor is:</p><pre><code class="language-julia">EnsembleProblem(prob::DEProblem;
                output_func = (sol,i) -&gt; (sol,false),
                prob_func= (prob,i,repeat)-&gt;(prob),
                reduction = (u,data,I)-&gt;(append!(u,data),false),
                u_init = [])</code></pre><ul><li><code>prob_func</code>: The function by which the problem is to be modified. <code>prob</code> is the problem, <code>i</code> is the unique id <code>1:trajectories</code> for the problem, and <code>repeat</code> is for if the iteration of the repeat. At first it&#39;s <code>0</code>, but if <code>rerun</code> was true this will be <code>1</code>, <code>2</code>, etc. counting the number of times problem <code>i</code> has been repeated.</li><li><code>output_func</code>: The function determines what is saved from the solution to the output array. Defaults to saving the solution itself. The output is <code>(out,rerun)</code> where <code>out</code> is the output and <code>rerun</code> is a boolean which designates whether to rerun</li><li><code>reduction</code>: This function determines how to reduce the data in each batch. Defaults to appending the data from the batches. The second part of the output determines whether the simulation has converged. If <code>true</code>, the simulation will exit early. By default, this is always <code>false</code>.</li></ul><p>One can specify a function <code>prob_func</code> which changes the problem. For example:</p><pre><code class="language-julia">function prob_func(prob,i,repeat)
  @. prob.u0 = randn()*prob.u0
  prob
end</code></pre><p>modifies the initial condition for all of the problems by a standard normal random number (a different random number per simulation). Notice that since problem types are immutable, it uses <code>.=</code>. Otherwise, one can just create a new problem type:</p><pre><code class="language-julia">function prob_func(prob,i,repeat)
  @. prob.u0 = u0_arr[i]
  prob
end</code></pre><p>If your function is a <code>ParameterizedFunction</code>, you can do similar modifications to <code>prob.f</code> to perform a parameter search. The <code>output_func</code> is a reduction function. It&#39;s arguments are the generated solution and the unique index for the run. For example, if we wish to only save the 2nd coordinate at the end of each solution, we can do:</p><pre><code class="language-julia">output_func(sol,i) = (sol[end,2],false)</code></pre><p>Thus the ensemble simulation would return as its data an array which is the end value of the 2nd dependent variable for each of the runs.</p><h3><a class="nav-anchor" id="Solving-the-Problem-1" href="#Solving-the-Problem-1">Solving the Problem</a></h3><pre><code class="language-julia">sim = solve(prob,alg,ensemblealg,kwargs...)</code></pre><p>The keyword arguments take in the arguments for the common solver interface and will pass them to the differential equation solver. The <code>ensemblealg</code> is optional, and will default to <code>EnsembleThreads()</code>. The special keyword arguments to note are:</p><ul><li><code>trajectories</code>: The number of simulations to run. This argument is required.</li><li><code>batch_size</code> : The size of the batches on which the reductions are applies. Defaults to <code>trajectories</code>.</li><li><code>pmap_batch_size</code>: The size of the <code>pmap</code> batches. Default is  <code>batch_sizeÃ·100 &gt; 0 ? batch_sizeÃ·100 : 1</code></li></ul><h3><a class="nav-anchor" id="EnsembleAlgorithms-1" href="#EnsembleAlgorithms-1">EnsembleAlgorithms</a></h3><p>The choice of ensemble algorithm allows for control over how the multiple trajectories are handled. Currently, the ensemble algorithm types are:</p><ul><li><code>EnsembleSerial()</code> - No parallelism</li><li><code>EnsembleThreads()</code> - The default. This uses multithreading. It&#39;s local (single computer, shared memory) parallelism only. Fastest when the trajectories are quick.</li><li><code>EnsembleDistributed()</code> - Uses <code>pmap</code> internally. It will use as many processors as you have Julia processes. To add more processes, use <code>addprocs(n)</code>. See Julia&#39;s documentation for more details. Recommended for the case when each trajectory calculation isn&#39;t &quot;too quick&quot; (at least about a millisecond each?).</li><li><code>EnsembleSplitThreads()</code> - This uses threading on each process, splitting the problem into <code>nprocs()</code> even parts. This is for solving many quick trajectories on a multi-node machine. It&#39;s recommended you have one process on each node.</li></ul><p>For example, <code>EnsembleThreads()</code> is invoked by:</p><pre><code class="language-julia">solve(ensembleprob,alg,EnsembleThreads();trajectories=1000)</code></pre><p>Additionally, an experimental GPU-based ensembling method is provided by DiffEqGPU.jl. Add and import that package to get <code>EnsembleGPUArray()</code>.</p><h3><a class="nav-anchor" id="Solution-Type-1" href="#Solution-Type-1">Solution Type</a></h3><p>The resulting type is a <code>EnsembleSimulation</code>, which includes the array of solutions.</p><h3><a class="nav-anchor" id="Plot-Recipe-1" href="#Plot-Recipe-1">Plot Recipe</a></h3><p>There is a plot recipe for a <code>AbstractEnsembleSimulation</code> which composes all of the plot recipes for the component solutions. The keyword arguments are passed along. A useful argument to use is <code>linealpha</code> which will change the transparency of the plots. An additional argument is <code>idxs</code> which allows you to choose which components of the solution to plot. For example, if the differential equation is a vector of 9 values, <code>idxs=1:2:9</code> will plot only the solutions of the odd components. An other additional argument is <code>zcolors</code> (an alias of <code>marker_z</code>) which allows you to pass a <code>zcolor</code> for each series. For details about <code>zcolor</code> see the  <a href="http://docs.juliaplots.org/dev/attributes/">Series documentation for Plots.jl</a>.</p><h2><a class="nav-anchor" id="Analyzing-an-Ensemble-Experiment-1" href="#Analyzing-an-Ensemble-Experiment-1">Analyzing an Ensemble Experiment</a></h2><p>Analysis tools are included for generating summary statistics and summary plots for a <code>EnsembleSimulation</code>.</p><p>To use this functionality, import the analysis module via:</p><pre><code class="language-julia">using DifferentialEquations.EnsembleAnalysis</code></pre><p>(or more directly <code>DiffEqBase.EnsembleAnalysis</code>).</p><h3><a class="nav-anchor" id="Time-steps-vs-time-points-1" href="#Time-steps-vs-time-points-1">Time steps vs time points</a></h3><p>For the summary statistics, there are two types. You can either summarize by time steps or by time points. Summarizing by time steps assumes that the time steps are all the same time point, i.e. the integrator used a fixed <code>dt</code> or the values were saved using <code>saveat</code>. Summarizing by time points requires interpolating the solution.</p><h3><a class="nav-anchor" id="Analysis-at-a-time-step-or-time-point-1" href="#Analysis-at-a-time-step-or-time-point-1">Analysis at a time step or time point</a></h3><pre><code class="language-julia">get_timestep(sim,i) # Returns an iterator of each simulation at time step i
get_timepoint(sim,t) # Returns an iterator of each simulation at time point t
componentwise_vectors_timestep(sim,i) # Returns a vector of each simulation at time step i
componentwise_vectors_timepoint(sim,t) # Returns a vector of each simulation at time point t</code></pre><h3><a class="nav-anchor" id="Summary-Statistics-1" href="#Summary-Statistics-1">Summary Statistics</a></h3><h4><a class="nav-anchor" id="Single-Time-Statistics-1" href="#Single-Time-Statistics-1">Single Time Statistics</a></h4><p>The available functions for time steps are:</p><pre><code class="language-julia">timestep_mean(sim,i) # Computes the mean of each component at time step i
timestep_median(sim,i) # Computes the median of each component at time step i
timestep_quantile(sim,q,i) # Computes the quantile q of each component at time step i
timestep_meanvar(sim,i)  # Computes the mean and variance of each component at time step i
timestep_meancov(sim,i,j) # Computes the mean at i and j, and the covariance, for each component
timestep_meancor(sim,i,j) # Computes the mean at i and j, and the correlation, for each component
timestep_weighted_meancov(sim,W,i,j) # Computes the mean at i and j, and the weighted covariance W, for each component</code></pre><p>The available functions for time points are:</p><pre><code class="language-julia">timepoint_mean(sim,t) # Computes the mean of each component at time t
timepoint_median(sim,t) # Computes the median of each component at time t
timepoint_quantile(sim,q,t) # Computes the quantile q of each component at time t
timepoint_meanvar(sim,t) # Computes the mean and variance of each component at time t
timepoint_meancov(sim,t1,t2) # Computes the mean at t1 and t2, the covariance, for each component
timepoint_meancor(sim,t1,t2) # Computes the mean at t1 and t2, the correlation, for each component
timepoint_weighted_meancov(sim,W,t1,t2) # Computes the mean at t1 and t2, the weighted covariance W, for each component</code></pre><h4><a class="nav-anchor" id="Full-Timeseries-Statistics-1" href="#Full-Timeseries-Statistics-1">Full Timeseries Statistics</a></h4><p>Additionally, the following functions are provided for analyzing the full timeseries. The <code>mean</code> and <code>meanvar</code> versions return a <code>DiffEqArray</code> which can be directly plotted. The <code>meancov</code> and <code>meancor</code> return a matrix of tuples, where the tuples are the <code>(mean_t1,mean_t2,cov or cor)</code>.</p><p>The available functions for the time steps are:</p><pre><code class="language-julia">timeseries_steps_mean(sim) # Computes the mean at each time step
timeseries_steps_median(sim) # Computes the median at each time step
timeseries_steps_quantile(sim,q) # Computes the quantile q at each time step
timeseries_steps_meanvar(sim) # Computes the mean and variance at each time step
timeseries_steps_meancov(sim) # Computes the covariance matrix and means at each time step
timeseries_steps_meancor(sim) # Computes the correlation matrix and means at each time step
timeseries_steps_weighted_meancov(sim) # Computes the weighted covariance matrix and means at each time step</code></pre><p>The available functions for the time points are:</p><pre><code class="language-julia">timeseries_point_mean(sim,ts) # Computes the mean at each time point in ts
timeseries_point_median(sim,ts) # Computes the median at each time point in ts
timeseries_point_quantile(sim,q,ts) # Computes the quantile q at each time point in ts
timeseries_point_meanvar(sim,ts) # Computes the mean and variance at each time point in ts
timeseries_point_meancov(sim,ts) # Computes the covariance matrix and means at each time point in ts
timeseries_point_meancor(sim,ts) # Computes the correlation matrix and means at each time point in ts
timeseries_point_weighted_meancov(sim,ts) # Computes the weighted covariance matrix and means at each time point in ts</code></pre><h3><a class="nav-anchor" id="EnsembleSummary-1" href="#EnsembleSummary-1">EnsembleSummary</a></h3><p>The <code>EnsembleSummary</code> type is included to help with analyzing the general summary statistics. Two constructors are provided:</p><pre><code class="language-julia">EnsembleSummary(sim;quantile=[0.05,0.95])
EnsembleSummary(sim,ts;quantile=[0.05,0.95])</code></pre><p>The first produces a <code>(mean,var)</code> summary at each time step. As with the summary statistics, this assumes that the time steps are all the same. The second produces a <code>(mean,var)</code> summary at each time point <code>t</code> in <code>ts</code>. This requires the ability to interpolate the solution. Quantile is used to determine the <code>qlow</code> and <code>qhigh</code> quantiles at each timepoint. It defaults to the 5% and 95% quantiles.</p><h4><a class="nav-anchor" id="Plot-Recipe-2" href="#Plot-Recipe-2">Plot Recipe</a></h4><p>The <code>EnsembleSummary</code> comes with a plot recipe for visualizing the summary statistics. The extra keyword arguments are:</p><ul><li><code>idxs</code>: the solution components to plot. Defaults to plotting all components.</li><li><code>error_style</code>: The style for plotting the error. Defaults to <code>ribbon</code>. Other choices are <code>:bars</code> for error bars and <code>:none</code> for no error bars.</li><li><code>ci_type</code> : Defaults to <code>:quantile</code> which has <code>(qlow,qhigh)</code> quantiles whose limits were determined when constructing the <code>EnsembleSummary</code>. Gaussian CI <code>1.96*(standard error of the mean)</code> can be set using <code>ci_type=:SEM</code>.</li></ul><p>One useful argument is <code>fillalpha</code> which controls the transparency of the ribbon around the mean.</p><h2><a class="nav-anchor" id="Example-1:-Solving-an-ODE-With-Different-Initial-Conditions-1" href="#Example-1:-Solving-an-ODE-With-Different-Initial-Conditions-1">Example 1: Solving an ODE With Different Initial Conditions</a></h2><h3><a class="nav-anchor" id="Random-Initial-Conditions-1" href="#Random-Initial-Conditions-1">Random Initial Conditions</a></h3><p>Let&#39;s test the sensitivity of the linear ODE to its initial condition. To do this, we would like to solve the linear ODE 100 times and plot what the trajectories look like. Let&#39;s start by opening up some extra processes so that way the computation will be parallelized. Here we will choose to use distributed parallelism which means  that the required functions must be made available to all processes. This can be  achieved with  <a href="https://docs.julialang.org/en/v1.2/stdlib/Distributed/#Distributed.@everywhere"><code>@everywhere</code> macro</a>:</p><pre><code class="language-julia">using Distributed
using DifferentialEquations
using Plots

addprocs()
@everywhere using DifferentialEquations</code></pre><p>Now let&#39;s define the linear ODE which is our base problem:</p><pre><code class="language-julia"># Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0
prob = ODEProblem((u,p,t)-&gt;1.01u,0.5,(0.0,1.0))</code></pre><p>For our ensemble simulation, we would like to change the initial condition around. This is done through the <code>prob_func</code>. This function takes in the base problem and modifies it to create the new problem that the trajectory actually solves. Here we will take the base problem, multiply the initial condition by a <code>rand()</code>, and use that for calculating the trajectory:</p><pre><code class="language-julia">@everywhere function prob_func(prob,i,repeat)
  ODEProblem(prob.f,rand()*prob.u0,prob.tspan)
end</code></pre><p>Now we build and solve the <code>EnsembleProblem</code> with this base problem and <code>prob_func</code>:</p><pre><code class="language-julia">ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)
sim = solve(ensemble_prob,Tsit5(),EnsembleDistributed(),trajectories=100)</code></pre><p>We can use the plot recipe to plot what the 100 ODEs look like:</p><pre><code class="language-julia">plotly()
plot(sim,linealpha=0.4)</code></pre><p><img src="../../assets/monte_carlo_plot.png" alt="monte_carlo_plot"/></p><p>We note that if we wanted to find out what the initial condition was for a given trajectory, we can retrieve it from the solution. <code>sim[i]</code> returns the <code>i</code>th solution object. <code>sim[i].prob</code> is the problem that specific trajectory solved, and <code>sim[i].prob.u0</code> would then be the initial condition used in the <code>i</code>th trajectory.</p><p>Note: If the problem has callbacks, the functions for the <code>condition</code> and <code>affect!</code> must be named functions (not anonymous functions).</p><h3><a class="nav-anchor" id="Using-multithreading-1" href="#Using-multithreading-1">Using multithreading</a></h3><p>The previous ensemble simulation can also be parallelized using a multithreading approach, which will make use of the different cores within a single computer. Because the memory is shared across the different threads, it is not necessary to use the <code>@everywhere</code> macro. Instead, the same problem can be implemented simply as:</p><pre><code class="language-julia">using DifferentialEquations
prob = ODEProblem((u,p,t)-&gt;1.01u,0.5,(0.0,1.0))
function prob_func(prob,i,repeat)
  ODEProblem(prob.f,rand()*prob.u0,prob.tspan)
end
ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)
sim = solve(ensemble_prob,Tsit5(),EnsembleThreads(),trajectories=100)</code></pre><p>The number of threads to be used has to be defined outside of Julia, in the environmental variable <code>JULIA_NUM_THREADS</code> (see Julia&#39;s <a href="https://docs.julialang.org/en/v1.1/manual/environment-variables/#JULIA_NUM_THREADS-1">documentation</a> for details).</p><h3><a class="nav-anchor" id="Pre-Determined-Initial-Conditions-1" href="#Pre-Determined-Initial-Conditions-1">Pre-Determined Initial Conditions</a></h3><p>In many cases, you may already know what initial conditions you want to use. This can be specified by the <code>i</code> argument of the <code>prob_func</code>. This <code>i</code> is the unique index of each trajectory. So, if we have <code>trajectories=100</code>, then we have <code>i</code> as some index in <code>1:100</code>, and it&#39;s different for each trajectory.</p><p>So, if we wanted to use a grid of evenly spaced initial conditions from <code>0</code> to <code>1</code>, we could simply index the <code>linspace</code> type:</p><pre><code class="language-julia">initial_conditions = range(0, stop=1, length=100)
function prob_func(prob,i,repeat)
  prob.u0 = initial_conditions[i]
  prob
end</code></pre><p>It&#39;s worth noting that if you run this code successfully, there will be no visible output. </p><h2><a class="nav-anchor" id="Example-2:-Solving-an-SDE-with-Different-Parameters-1" href="#Example-2:-Solving-an-SDE-with-Different-Parameters-1">Example 2: Solving an SDE with Different Parameters</a></h2><p>Let&#39;s solve the same SDE but with varying parameters. Let&#39;s create a Lotka-Volterra  system with multiplicative noise. Our Lotka-Volterra system will have as its  drift component:</p><pre><code class="language-julia">function f(du,u,p,t)
  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]
  du[2] = -3 * u[2] + u[1]*u[2]
end</code></pre><p>For our noise function we will use multiplicative noise:</p><pre><code class="language-julia">function g(du,u,p,t)
  du[1] = p[3]*u[1]
  du[2] = p[4]*u[2]
end</code></pre><p>Now we build the SDE with these functions:</p><pre><code class="language-julia">p = [1.5,1.0,0.1,0.1]
prob = SDEProblem(f,g,[1.0,1.0],(0.0,10.0),p)</code></pre><p>This is the base problem for our study. What would like to do with this experiment is keep the same parameters in the deterministic component each time, but very the parameters for the amount of noise using <code>0.3rand(2)</code> as our parameters. Once again, we do this with a <code>prob_func</code>, and here we modify the parameters in <code>prob.p</code>:</p><pre><code class="language-julia">function prob_func(prob,i,repeat)
  prob.p[3:4] = 0.3rand(2)
  prob
end</code></pre><p>Now we solve the problem 10 times and plot all of the trajectories in phase space:</p><pre><code class="language-julia">ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)
sim = solve(ensemble_prob,SRIW1(),trajectories=10)
using Plots; plotly()
using Plots; plot(sim,linealpha=0.6,color=:blue,vars=(0,1),title=&quot;Phase Space Plot&quot;)
plot!(sim,linealpha=0.6,color=:red,vars=(0,2),title=&quot;Phase Space Plot&quot;)</code></pre><p><img src="../../assets/monte_carlo_blue.png" alt="monte_lotka_blue"/></p><p>We can then summarize this information with the mean/variance bounds using a <code>EnsembleSummary</code> plot. We will take the mean/quantile at every <code>0.1</code> time units and directly plot the summary:</p><pre><code class="language-julia">summ = EnsembleSummary(sim,0:0.1:10)
pyplot() # Note that plotly does not support ribbon plots
plot(summ,fillalpha=0.5)</code></pre><p><img src="../../assets/monte_carlo_quantile.png" alt="monte_carlo_quantile"/></p><p>Note that here we used the quantile bounds, which default to <code>[0.05,0.95]</code> in the <code>EnsembleSummary</code> constructor. We can change to standard error of the mean bounds using <code>ci_type=:SEM</code> in the plot recipe.</p><h2><a class="nav-anchor" id="Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance-1" href="#Example-3:-Using-the-Reduction-to-Halt-When-Estimator-is-Within-Tolerance-1">Example 3: Using the Reduction to Halt When Estimator is Within Tolerance</a></h2><p>In this problem we will solve the equation just as many times as needed to get the standard error of the mean for the final time point below our tolerance <code>0.5</code>. Since we only care about the endpoint, we can tell the <code>output_func</code> to discard the rest of the data.</p><pre><code class="language-julia">function output_func(sol,i)
  last(sol)
end</code></pre><p>Our <code>prob_func</code> will simply randomize the initial condition:</p><pre><code class="language-julia"># Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0
prob = ODEProblem((u,p,t)-&gt;1.01u,0.5,(0.0,1.0))

function prob_func(prob,i,repeat)
  ODEProblem(prob.f,rand()*prob.u0,prob.tspan)
end</code></pre><p>Our reduction function will append the data from the current batch to the previous batch, and declare convergence if the standard error of the mean is calculated as sufficiently small:</p><pre><code class="language-julia">function reduction(u,batch,I)
  u = append!(u,batch)
  u,((var(u)/sqrt(last(I)))/mean(u)&lt;0.5) ? true : false
end</code></pre><p>Then we can define and solve the problem:</p><pre><code class="language-julia">prob2 = EnsembleProblem(prob,prob_func=prob_func,output_func=output_func,reduction=reduction,u_init=Vector{Float64}())
sim = solve(prob2,Tsit5(),trajectories=10000,batch_size=20)</code></pre><p>Since <code>batch_size=20</code>, this means that every 20 simulations, it will take this batch, append the results to the previous batch, calculate <code>(var(u)/sqrt(last(I)))/mean(u)</code>, and if that&#39;s small enough, exit the simulation. In this case, the simulation exits only after 20 simulations (i.e. after calculating the first batch). This can save a lot of time!</p><p>In addition to saving time by checking convergence, we can save memory by reducing between batches. For example, say we only care about the mean at the end once again. Instead of saving the solution at the end for each trajectory, we can instead save the running summation of the endpoints:</p><pre><code class="language-julia">function reduction(u,batch,I)
  u+sum(batch),false
end
prob2 = EnsembleProblem(prob,prob_func=prob_func,output_func=output_func,reduction=reduction,u_init=0.0)
sim2 = solve(prob2,Tsit5(),trajectories=100,batch_size=20)</code></pre><p>this will sum up the endpoints after every 20 solutions, and save the running sum. The final result will have <code>sim2.u</code> as simply a number, and thus <code>sim2.u/100</code> would be the mean.</p><h2><a class="nav-anchor" id="Example-4:-Using-the-Analysis-Tools-1" href="#Example-4:-Using-the-Analysis-Tools-1">Example 4: Using the Analysis Tools</a></h2><p>In this example we will show how to analyze a <code>EnsembleSolution</code>. First, let&#39;s generate a 10 solution Monte Carlo experiment. For our problem we will use a <code>4x2</code> system of linear stochastic differential equations:</p><pre><code class="language-julia">function f(du,u,p,t)
  for i = 1:length(u)
    du[i] = 1.01*u[i]
  end
end
function Ï(du,u,p,t)
  for i in 1:length(u)
    du[i] = .87*u[i]
  end
end
prob = SDEProblem(f,Ï,ones(4,2)/2,(0.0,1.0)) #prob_sde_2Dlinear</code></pre><p>To solve this 10 times, we use the <code>EnsembleProblem</code> constructor and solve with <code>trajectories=10</code>. Since we wish to compare values at the timesteps, we need to make sure the steps all hit the same times. Thus we set <code>adaptive=false</code> and explicitly give a <code>dt</code>.</p><pre><code class="language-julia">prob2 = EnsembleProblem(prob)
sim = solve(prob2,SRIW1(),dt=1//2^(3),trajectories=10,adaptive=false)</code></pre><p><strong>Note that if you don&#39;t do the <code>timeseries_steps</code> calculations, this code is compatible with adaptive timestepping. Using adaptivity is usually more efficient!</strong></p><p>We can compute the mean and the variance at the 3rd timestep using:</p><pre><code class="language-julia">m,v = timestep_meanvar(sim,3)</code></pre><p>or we can compute the mean and the variance at the <code>t=0.5</code> using:</p><pre><code class="language-julia">m,v = timepoint_meanvar(sim,0.5)</code></pre><p>We can get a series for the mean and the variance at each time step using:</p><pre><code class="language-julia">m_series,v_series = timeseries_steps_meanvar(sim)</code></pre><p>or at chosen values of <code>t</code>:</p><pre><code class="language-julia">ts = 0:0.1:1
m_series = timeseries_point_mean(sim,ts)</code></pre><p>Note that these mean and variance series can be directly plotted. We can compute covariance matrices similarly:</p><pre><code class="language-julia">timeseries_steps_meancov(sim) # Use the time steps, assume fixed dt
timeseries_point_meancov(sim,0:1//2^(3):1,0:1//2^(3):1) # Use time points, interpolate</code></pre><p>For general analysis, we can build a <code>EnsembleSummary</code> type.</p><pre><code class="language-julia">summ = EnsembleSummary(sim)</code></pre><p>will summarize at each time step, while</p><pre><code class="language-julia">summ = EnsembleSummary(sim,0.0:0.1:1.0)</code></pre><p>will summarize at the <code>0.1</code> time points using the interpolations. To visualize the results we can plot it. Since there are 8 components to the differential equation, this can get messy, so let&#39;s only plot the 3rd component:</p><pre><code class="language-julia">plot(summ;idxs=3)</code></pre><p><img src="../../assets/monte_ribbon.png" alt="monte_ribbon"/></p><p>We can change to errorbars instead of ribbons and plot two different indices:</p><pre><code class="language-julia">plot(summ;idxs=(3,5),error_style=:bars)</code></pre><p><img src="../../assets/monte_bars.png" alt="monte_bars"/></p><p>Or we can simply plot the mean of every component over time:</p><pre><code class="language-julia">plot(summ;error_style=:none)</code></pre><p><img src="../../assets/monte_means.png" alt="monte_means"/></p><footer><hr/><a class="previous" href="../callback_library/"><span class="direction">Previous</span><span class="title">Callback Library</span></a><a class="next" href="../io/"><span class="direction">Next</span><span class="title">I/O: Saving and Loading Solution Data</span></a></footer></article></body></html>
