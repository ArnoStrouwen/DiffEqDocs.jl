<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty Quantification Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.juliadiffeq.org/stable/analysis/uncertainty_quantification/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="toctext" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="toctext" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="toctext" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="toctext" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="toctext" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="toctext" href="../../basics/solution/">Solution Handling</a></li><li><a class="toctext" href="../../basics/plot/">Plot Functions</a></li><li><a class="toctext" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="toctext" href="../../basics/problem/">Problem Interface</a></li><li><a class="toctext" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="toctext" href="../../types/ode_types/">ODE Problems</a></li><li><a class="toctext" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="toctext" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="toctext" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="toctext" href="../../types/sde_types/">SDE Problems</a></li><li><a class="toctext" href="../../types/rode_types/">RODE Problems</a></li><li><a class="toctext" href="../../types/dde_types/">DDE Problems</a></li><li><a class="toctext" href="../../types/dae_types/">DAE Problems</a></li><li><a class="toctext" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="toctext" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="toctext" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="toctext" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="toctext" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="toctext" href="../../solvers/jump_solve/">Jump Problem Solvers</a></li><li><a class="toctext" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="toctext" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="toctext" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="toctext" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="toctext" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="toctext" href="../../features/noise_process/">Noise Processes</a></li><li><a class="toctext" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../../features/callback_library/">Callback Library</a></li><li><a class="toctext" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="toctext" href="../../features/progress_bar/">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../parameterized_functions/">ParameterizedFunctions</a></li><li><a class="toctext" href="../parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../bifurcation/">Bifurcation Analysis</a></li><li><a class="toctext" href="../sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../global_sensitivity/">Global Sensitivity Analysis</a></li><li class="current"><a class="toctext" href>Uncertainty Quantification</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#ProbInts-1">ProbInts</a></li><li><a class="toctext" href="#Example-1:-FitzHugh-Nagumo-1">Example 1: FitzHugh-Nagumo</a></li><li><a class="toctext" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1">Example 2: Adaptive ProbInts on FitzHugh-Nagumo</a></li><li><a class="toctext" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1">Example 3: Adaptive ProbInts on the Lorenz Attractor</a></li></ul></li><li><a class="toctext" href="../neural_networks/">Neural Networks</a></li><li><a class="toctext" href="../dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="toctext" href="../../models/physical/">Physical Models</a></li><li><a class="toctext" href="../../models/financial/">Financial Models</a></li><li><a class="toctext" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="toctext" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><span class="toctext">DiffEqBase API</span><ul><li><a class="toctext" href="../../apis/diffeqbase/overview/">Overview</a></li><li><a class="toctext" href="../../apis/diffeqbase/functions/">DE functions</a></li><li><a class="toctext" href="../../apis/diffeqbase/problems/">Problems</a></li><li><a class="toctext" href="../../apis/diffeqbase/solutions/">Solutions</a></li><li><a class="toctext" href="../../apis/diffeqbase/solvers/">Solvers</a></li><li><a class="toctext" href="../../apis/diffeqbase/de_types/">DE types</a></li><li><a class="toctext" href="../../apis/diffeqbase/operators/">Operators</a></li><li><a class="toctext" href="../../apis/diffeqbase/callbacks/">Callbacks</a></li><li><a class="toctext" href="../../apis/diffeqbase/interpolation/">Interpolation</a></li><li><a class="toctext" href="../../apis/diffeqbase/ensembles/">Ensembles</a></li><li><a class="toctext" href="../../apis/diffeqbase/data_arrays/">Data arrays</a></li><li><a class="toctext" href="../../apis/diffeqbase/noise/">Noise processes</a></li><li><a class="toctext" href="../../apis/diffeqbase/utility/">Utility</a></li></ul></li><li><a class="toctext" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Analysis Tools</li><li><a href>Uncertainty Quantification</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/analysis/uncertainty_quantification.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Uncertainty Quantification</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Uncertainty-Quantification-1" href="#Uncertainty-Quantification-1">Uncertainty Quantification</a></h1><p>Uncertainty quantification allows a user to identify the uncertainty associated with the numerical approximation given by DifferentialEquations.jl. This page describes the different methods available for quantifying such uncertainties. Note that this requires one of the native Julia solvers like OrdinaryDiffEq.jl, StochasticDiffEq.jl, or DelayDiffEq.jl.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>This functionality does not come standard with DifferentialEquations.jl. To use this functionality, you must install DiffEqUncertainty.jl:</p><pre><code class="language-julia">]add DiffEqUncertainty
using DiffEqUncertainty</code></pre><h2><a class="nav-anchor" id="ProbInts-1" href="#ProbInts-1">ProbInts</a></h2><p>The <a href="http://www2.warwick.ac.uk/fac/sci/statistics/staff/academic-research/girolami/probints">ProbInts</a> method for uncertainty quantification involves the transformation of an ODE into an associated SDE where the noise is related to the timesteps and the order of the algorithm. This is implemented into the DiffEq system via a callback function. The first form is:</p><pre><code class="language-julia">ProbIntsUncertainty(Ï,order,save=true)</code></pre><p><code>Ï</code> is the noise scaling factor and <code>order</code> is the order of the algorithm. <code>save</code> is for choosing whether this callback should control the saving behavior. Generally this is true unless one is stacking callbacks in a <code>CallbackSet</code>. It is recommended that <code>Ï</code> is representative of the size of the errors in a single step of the equation.</p><p>If you are using an adaptive algorithm, the callback</p><pre><code class="language-julia">AdaptiveProbIntsUncertainty(order,save=true)</code></pre><p>determines the noise scaling automatically using an internal error estimate.</p><h2><a class="nav-anchor" id="Example-1:-FitzHugh-Nagumo-1" href="#Example-1:-FitzHugh-Nagumo-1">Example 1: FitzHugh-Nagumo</a></h2><p>In this example we will determine our uncertainty when solving the FitzHugh-Nagumo model with the <code>Euler()</code> method. We define the FitzHugh-Nagumo model:</p><pre><code class="language-julia">function fitz(du,u,p,t)
  V,R = u
  a,b,c = p
  du[1] = c*(V - V^3/3 + R)
  du[2] = -(1/c)*(V -  a - b*R)
end
u0 = [-1.0;1.0]
tspan = (0.0,20.0)
p = (0.2,0.2,3.0)
prob = ODEProblem(fitz,u0,tspan,p)</code></pre><p>Now we define the <code>ProbInts</code> callback. In this case, our method is the <code>Euler</code> method and thus it is order 1. For the noise scaling, we will try a few different values and see how it changes. For <code>Ï=0.2</code>, we define the callback as:</p><pre><code class="language-julia">cb = ProbIntsUncertainty(0.2,1)</code></pre><p>This is akin to having an error of approximately 0.2 at each step. We now build and solve a <a href="../../features/ensemble/">EnsembleProblem</a> for 100 trajectories:</p><pre><code class="language-julia">ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Euler(),trajectories=100,callback=cb,dt=1/10)</code></pre><p>Now we can plot the resulting Monte Carlo solution:</p><pre><code class="language-julia">using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_02.png" alt="uncertainty_02"/></p><p>If we increase the amount of error, we see that some parts of the equation have less uncertainty than others. For example, at <code>Ï=0.5</code>:</p><pre><code class="language-julia">cb = ProbIntsUncertainty(0.5,1)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Euler(),trajectories=100,callback=cb,dt=1/10)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_05.png" alt="uncertainty_05"/></p><p>But at this amount of noise, we can see how we contract to the true solution by decreasing <code>dt</code>:</p><pre><code class="language-julia">cb = ProbIntsUncertainty(0.5,1)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Euler(),trajectories=100,callback=cb,dt=1/100)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_lowh.png" alt="uncertainty_lowh"/></p><h2><a class="nav-anchor" id="Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1">Example 2: Adaptive ProbInts on FitzHugh-Nagumo</a></h2><p>While the first example is academic and shows how the ProbInts method scales, the fact that one should have some idea of the error in order to calibrate <code>Ï</code> can lead to complications. Thus the more useful method in many cases is the <code>AdaptiveProbIntsUncertainty</code> version. In this version, no <code>Ï</code> is required since this is calculated using an internal error estimate. Thus this gives an accurate representation of the possible error without user input.</p><p>Let&#39;s try this with the order 5 <code>Tsit5()</code> method on the same problem as before:</p><pre><code class="language-julia">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob,Tsit5())
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Tsit5(),trajectories=100,callback=cb)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_adaptive_default.png" alt="uncertainty_adaptive_default"/></p><p>In this case, we see that the default tolerances give us a very good solution. However, if we increase the tolerance a lot:</p><pre><code class="language-julia">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob,Tsit5())
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Tsit5(),trajectories=100,callback=cb,abstol=1e-3,reltol=1e-1)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_high_tolerance.png" alt="uncertainty_adaptive_default"/></p><p>we can see that the moments just after the rise can be uncertain.</p><h2><a class="nav-anchor" id="Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1">Example 3: Adaptive ProbInts on the Lorenz Attractor</a></h2><p>One very good use of uncertainty quantification is on chaotic models. Chaotic equations diverge from the true solution according to the error exponentially. This means that as time goes on, you get further and further from the solution. The <code>ProbInts</code> method can help diagnose how much of the timeseries is reliable.</p><p>As in the previous example, we first define the model:</p><pre><code class="language-julia">function g(du,u,p,t)
 du[1] = p[1]*(u[2]-u[1])
 du[2] = u[1]*(p[2]-u[3]) - u[2]
 du[3] = u[1]*u[2] - p[3]*u[3]
end
u0 = [1.0;0.0;0.0]
tspan = (0.0,30.0)
p = [10.0,28.0,8/3]
prob = ODEProblem(g,u0,tspan,p)</code></pre><p>and then we build the <code>ProbInts</code> type. Let&#39;s use the order 5 <code>Tsit5</code> again.</p><pre><code class="language-julia">cb = AdaptiveProbIntsUncertainty(5)</code></pre><p>Then we solve the <code>MonteCarloProblem</code></p><pre><code class="language-julia">ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Tsit5(),trajectories=100,callback=cb)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_chaos.png" alt="uncertainty_chaos"/></p><p>Here we see that by <code>t</code> about 22 we start to receive strong deviations from the &quot;true&quot; solution. We can increase the amount of time before error explosion by using a higher order method with stricter tolerances:</p><pre><code class="language-julia">tspan = (0.0,40.0)
prob = ODEProblem(g,u0,tspan,p)
cb = AdaptiveProbIntsUncertainty(7)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Vern7(),trajectories=100,callback=cb,reltol=1e-6)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_high_order.png" alt="uncertainty_high_order"/></p><p>we see that we can extend the amount of time until we deviate strongly from the &quot;true&quot; solution. Of course, for a chaotic system like the Lorenz one presented here, it is impossible to follow the true solution for long times, due to the fact that the system is chaotic and unavoidable deviations due to the numerical precision of a cumputer get amplified exponentially.</p><p>However, not all hope is lost. The <a href="http://mathworld.wolfram.com/ShadowingTheorem.html">shadowing theorem</a> is a strong statement for having confidence in numerical evolution of chaotic systems:</p><blockquote><p>Although a numerically computed chaotic trajectory diverges exponentially from the true trajectory with the same initial coordinates, there exists an errorless trajectory with a slightly different initial condition that stays near (&quot;shadows&quot;) the numerically computed one.</p></blockquote><p>For more info on the shadowing theorem, please see the book <em>Chaos in Dynamical Systems</em> by E. Ott.</p><footer><hr/><a class="previous" href="../global_sensitivity/"><span class="direction">Previous</span><span class="title">Global Sensitivity Analysis</span></a><a class="next" href="../neural_networks/"><span class="direction">Next</span><span class="title">Neural Networks</span></a></footer></article></body></html>
